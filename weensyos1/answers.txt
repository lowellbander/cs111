Name: Lowell Bander
UCLA ID: 204 156 534

Name: Nicole Yee
UCLA ID: 403 796 037


-------------------------------------------------------------------------------

Response to Exercise 1:

When the process that called sys_getpid() eventually runs again, the call to
sys_getpid() will have returned the correct value because schedule() simply
iterates through the array of all processes, executing processes that are
runnable. When schedule() reaches the process that called sys_getpid(), it
will call run() on this process, which will in turn return the correct pid.


Response to Exercise 3:

We added a wait queue to the process descriptor, namely a pointer to another
process. Inside INT_SYS_WAIT, if the calling process (current) has not exited 
yet, it is added to the wait queue described above by storing a pointer to the
current process into p_queue of proc_array[p]. The calling process is then
put to sleep, by setting the state to P_BLOCKED. In INT_SYS_EXIT, the current
process checks to see if there is anything in the wait queue. If so, the
queued process is woken up, by setting the status to P_RUNNABLE. The exit
status of the current process is passed on to the queued process by being
placed in the queued process's %eax register.

Anything else you'd like us to know:



Extra credit exercises:

Code for Exercise 5:

void start(void)
{
  int x = 0;  /* note that local variable x lives on the stack */
  
  volatile int* i = &x; // non-volatile pointer to volatile integer
  int* volatile j = &x; // volatile pointer to non-volatile integer
  
  pid_t p = sys_fork();
  if (p == 0)
  {
    i = &x; 
    *i = 1; 
    
    j = &x; 
    *j = 1; 
  } 
  else if (p > 0)
    sys_wait(p); // assume blocking implementation
  app_printf("%d", x);
  sys_exit(0);
}


